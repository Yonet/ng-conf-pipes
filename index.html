<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Pipe Hype</title>

	<meta name="description" content="Ng-conf 2016 Slides">
	<meta name="author" content="Aysegul Yonet">

	<meta name="apple-mobile-web-app-capable" content="yes"/>
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/a360.css" id="theme">

	<!-- For syntax highlighting -->
	<!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
	<script src="vendor/angular.js"></script>
	<style>
		foo-code {
			padding: 0.8em;
			background: #f0edf7;
			display: block;
			color: #aaa;
		}
	</style>
</head>

<body ng-app="slides">

<div class="reveal">

	<!-- Any section element inside of this container is displayed as a slide -->
	<div class="slides">

		<section class="">
			<h1>Pipe Hype</h1>
		</section>

		<section class="sub-section-slide" data-background-transition="slide" data-background="#8092c4">
			<h2></h2>
			<p><a href="https://twitter.com/AysegulYonet" target="_blank" style="color:#fff">@AysegulYonet</a></p>
			<!--TODO add logo-->
		</section>

		<!--<section class="" data-background="#8092c4">-->
			<!--<h2>Don't look at my data, it is hideous!</h2>-->
		<!--</section>-->

        <!--<section>-->
            <!--<div>-->
                <!--<h2>Pipes</h2>-->

		  <!--<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><code>-->
              <!--<span>{{file?.lastModified | date}}</span>-->
          <!--</code></pre>-->
            <!--</div>-->
            <!--<aside class="notes">A pipe takes in data as input and transforms it to a desired output.</aside>-->
        <!--</section>-->

        <!--<section>-->
            <!--<div>-->
                <!--<h2>Pipes</h2>-->

		  <!--<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><code>-->
              <!--<span>{{file?.lastModified | date:}}</span>-->
          <!--</code></pre>-->
            <!--</div>-->
            <!--<aside class="notes">A pipe takes in data as input and transforms it to a desired output.</aside>-->
        <!--</section>-->

		<!--<section>-->
			<!--<div class="fragment">-->
				<!--<h2>Pipes</h2>-->

		  <!--<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><code>@Component({-->
<!--selector: 'file-detail',-->
<!--template: `-->
  <!--<span>Last Modified:</span>-->
  <!--<span>{{file?.lastModified | date}}</span>-->

<!--`-->
<!--})-->
<!--class FileDetailComponent { }</code></pre>-->
			<!--</div>-->
			<!--<aside class="notes">A pipe takes in data as input and transforms it to a desired output.</aside>-->
		<!--</section>-->

		<section>
			<h2>Pipes</h2>

		  <pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>@Component({
selector: 'file-detail',
template: `
  &lt;span&gt;Last Modified:&lt;/span&gt;
  &lt;p&gt;<span style="color: #000;">{{file?.lastModified | date}}</span>&lt;/p&gt;

  `
})
class FileDetailComponent { }</foo-code></pre>
            <aside class="notes">We still have the familiar sytax of pipe in our templates</aside>

		</section>

		<section>
			<h2>Pipes Parameters</h2>

		  <pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>@Component({
selector: 'file-detail',
template: `
  &lt;span&gt;Last Modified:&lt;/span&gt;
  &lt;p&gt;<span style="color: #000;">{{file?.lastModified | date:"MM/dd/yy"}}</span>&lt;/p&gt;

`
})
class FileDetailComponent { }</foo-code></pre>
			<aside class="notes">A pipe may accept any number of optional parameters to fine-tune its output.</aside>
		</section>
		<section>
			<h2>Pipes Parameters</h2>

		  <pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>@Component({
selector: 'file-detail',
template: `
  &lt;span&gt;Last Modified:&lt;/span&gt;
  &lt;p&gt;<span style="color: #000;">{{file?.lastModified | date:"MM/dd/yy"}}</span>&lt;/p&gt;
  <span style="color: #000;">&lt;input [(ngModel)]="format"&gt;</span>
`
})
class FileDetailComponent { }</foo-code></pre>
			<aside class="notes">The parameter value can be any valid template expression such as a string literal or component property.
				In other words, we can control the format through a binding</aside>
                </section>

                <!--Replace Pipe-->
		<section>
			<h2>ReplacePipe</h2>

		  <pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>@Component({
...
template: `
  &lt;span&gt;Last Modified:&lt;/span&gt;
  &lt;p&gt;<span style="color: #000;">{{ expression | replace:pattern:replacement}}</span>&lt;/p&gt;
`
})

class FileDetailComponent { }</foo-code></pre>
            <p><a href="https://plnkr.co/edit/vYDCnojcr3PizzQbZNjN?p=preview" target="_blank">Plunker</a></p>
			<aside class="notes">Can we write our own parameters with regex?
                Replace pipe Creates a new String with some or all of the matches of a pattern replaced by
				* a replacement.</aside>
		</section>
		<section>
			<h2>ReplacePipe</h2>

		  <pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>@Component({
  template: `
  &lt;span&gt;Made with:&lt;/span&gt;
  &lt;p&gt;<span style="color: #000;">Hello {{name | replace:pattern:'2.0'}}</span>&lt;/p&gt;`})
  <span style="color: #000;">class ReplacePipeComponent {
    constructor() {
	  this.name = 'Angular 1.5'
	  this.pattern = new RegExp(/(?:\d*\.)?\d+/g);
	}
  }</span></foo-code></pre>
			<aside class="notes">https://plnkr.co/edit/vYDCnojcr3PizzQbZNjN?p=preview</aside>
		</section>

		<section>
			<h2>JsonPipe</h2>

		  <pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>@Component({
selector: 'file-detail',
template: `
  &lt;span&gt;File:&lt;/span&gt;
  &lt;p&gt;<span style="color: #000;">{{file | json}}</span>&lt;/p&gt;
`
})
class FileDetailComponent { }</foo-code></pre>
			<aside class="notes">Cool new addition to angular 2 is json pipe,
                it is very helps with debugging.
                Still angular pipes are very limited in number, we will end up writing our custom pipes.
                Let's get to it.
            </aside>
		</section>
        <section class="sub-section-slide" data-background-transition="slide" data-background="#8092c4">
            <h2>Custom Pipes</h2>
        </section>

		<section>
		<h2>Custom Pipes</h2>
		<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code><span style="color: #000;">import {Pipe,PipeTransform} from 'angular2/core'
@Pipe</span>({name: 'trim'})
export class TrimPipe implements PipeTransform {
  transform(str:string, [length]) : string {
	if (!str || !length || str.length <= length) {
	  return (str || '');
	}
    let dots = length <= 3 ? '' : '...';
    return str.substr(0, length) + dots;
  }
}
		</foo-code></pre>
            <aside class="notes">A pipe is a class decorated with pipe metadata. We implement the transform method of PipeTransform interface.
                The @Pipe decorator takes an object with a name property whose value is the pipe name that we'll use within a template expression.
                Then we can define the transform method to format our input to our desired output.
            </aside>
		</section>
        <section>
            <h2>Custom Pipes</h2>
		<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>import {Pipe,PipeTransform} from 'angular2/core'
@Pipe(<span style="color: #000;">{name: 'trim'}</span>)
export class TrimPipe implements PipeTransform {
  transform(str:string, [length]) : string {
    if (!str || !length || str.length <= length) {
      return (str || '');
    }
    let dots = length <= 3 ? '' : '...';
      return str.substr(0, length) + dots;
  }
}
        </foo-code></pre>
            <aside class="notes">A pipe is a class decorated with pipe metadata. We implement the transform method of PipeTransform interface.
                The @Pipe decorator takes an object with a name property whose value is the pipe name that we'll use within a template expression.
                Then we can define the transform method to format our input to our desired output.
            </aside>
        </section>
        <section>
            <h2>Custom Pipes</h2>
		<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>import {Pipe,PipeTransform} from 'angular2/core'
@Pipe({name: 'trim'})
export class TrimPipe implements PipeTransform {
  <span style="color: #000;">transform(str:string, [length]) : string </span>{
    if (!str || !length || str.length <= length) {
      return (str || '');
    }
    let dots = length <= 3 ? '' : '...';
    <span style="color: #000;">return str.substr(0, length) + dots;</span>
  }
}
        </foo-code></pre>
            <aside class="notes">A pipe is a class decorated with pipe metadata. We implement the transform method of PipeTransform interface.
                The @Pipe decorator takes an object with a name property whose value is the pipe name that we'll use within a template expression.
                Then we can define the transform method to format our input to our desired output.
            </aside>
        </section>

		<section>
            <!--TODO add an example video of not working pure pipe-->
		<h2>Pipes and Change Detection</h2>
		<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>import {Pipe,
PipeTransform} from 'angular2/core';
@Pipe({name: 'shared'})
export class SharedPipe implements PipeTransform {
  transform(files:File[]) {
  return files.filter(file => file.shared);
}
}
		</foo-code></pre>
		<aside class="notes">What makes angular2 pipes more efficient is the way it detects change.
        By default angular2 pipes are pure. What is a pure pipe?
        </aside>
		</section>
		<section>
		<h2>Pipes and Change Detection</h2>
		<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>
<div *ngFor="let file of (files | shared)">
  &lt;input type=checbox&gt; [(ngModel)]="file.shared"
  {{file.name}}
</div></foo-code></pre>
		<aside class="notes">The object reference to the array hasn't changed. It's the same array. That's all
		Angular cares about. From its perspective, same array, no change, no display update.
		</aside>
		</section>

		<section>
		<h2>Pure and Impure Pipes</h2>
		<aside class="notes">Pipes are pure by default.</aside>
		</section>

		<section>
		<h2>Pure Pipes</h2>
		<p>Angular executes a pure pipe only when it detects a pure change to the input value.</p>
<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>
class FilesComponent {
constructor(){...}
this.files.push(newFile);
}

</foo-code></pre>
		<aside class="notes">A pure change is either a change to a primitive input value (String, Number, Boolean,
		Symbol) or a changed object reference (Date, Array, Function, Object).
		</aside>
		</section>

		<section>
		<h2>Impure Pipes</h2>
<pre ng-non-bindable style="font-size: 1.2em; line-height: 40px; margin-top: 1.5em;"><foo-code>

@Pipe({name: 'shared', pure: false})
export class SharedPipe implements PipeTransform {
transform(files:File[]) {
return files.filter(file => file.shared);
}
}
</foo-code></pre>
		<aside class="notes">Angular executes an impure pipe during every component change detection cycle.
		An impure pipe will be called a lot, as often as every keystroke or mouse-move.

		</aside>
		</section>

		<!--AsyncPipe-->
		<section>
			<h2>AsyncPipe</h2>

		<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><code>import {Observable} from 'rxjs/Observable';

@Component(...)
class FilesListComponent {

  contacts: Observable&lt;Array&lt;File&gt;&gt;;

  constructor(filesService: FilesService) {
	this.files = filesService.getFiles();
  }
}</code></pre>
			<aside class="notes">Angular AsyncPipe is an interesting example of an impure pipe. The Async pipe can
				receive a Promise or Observable as input and subscribe to the input changes automatically.
				It is also stateful. The pipe maintains a subscription to the input Observable and keeps delivering
				values from that Observable as they arrive.
				</aside>
		</section>

		<section>
			<h2>AsyncPipe</h2>

		<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><foo-code><span style="color: #000;">import {Observable} from 'rxjs/Observable';</span>

@Component(...)
class FilesListComponent {

    contacts: <span style="color: #000;">Observable&lt;Array&lt;Contact&gt;&gt;;</span>

    constructor(filesService: FilesService) {
        <span style="color: #000;">this.files = filesService.getFiles();</span>
    }
}</foo-code></pre>
			<aside class="notes">The Async pipe saves boilerplate in the component code. The component doesn't have to
			subscribe to the async data source, it doesn't extract the resolved values and expose them for binding,
			and the component doesn't have to unsubscribe when it is destroyed (a potent source of memory leaks).
			</aside>
		</section>

		<section>
			<h2>AsyncPipe</h2>

		<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><code>@Component({
template:
  &lt;ul&gt;
    &lt;li *ngFor="let file of files | async"&gt;
	  ...
    &lt;/li&gt;
  &lt;/ul&gt;
`
})
class FilesListComponent {...}</code></pre>
		</section>

		<section>
			<h2>AsyncPipe</h2>

		<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><foo-code>@Component({
template: `
  &lt;ul&gt;
	&lt;li *ngFor="<span style="color: #000;">let file of files | async</span>"&gt;
	  ...
	&lt;/li&gt;
  &lt;/ul&gt;
`
})
class FilesListComponent {...}</foo-code></pre>
		</section>
		<!--/AsyncPipe-->

		<section>
			<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><code>@Pipe({name:
'fetch'})
export class FetchJsonPipe implements PipeTransform{
  private fetched:any = null;
  constructor(private _http: Http) { }
  transform(url:string):any {
  this.fetched = null;
  this._http.get(url)
    .map( result => result.json() )
    .subscribe( result => this.fetched = result )
  }
  return this.fetched;
 }
}</code></pre>
			<aside class="notes">You are in trouble if you make this inpure</aside>
		</section>


		<section>
<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><code>
<div *ngFor="let file of ('filesApiUrl' | fetch) | async">
{{file.name}}
</div>
</code></pre>
			<aside class="notes">This looks great but still not an ideal way</aside>
		</section>
		<section>
			<h2>Performance Upgrade</h2>
			<a href="">Demo</a>
		</section>
		<section>
			<h2>Can we do better?</h2>
<pre ng-non-bindable style="font-size: 1.2em; line-height: 35px; margin-top: 1.5em;"><code>
<div *ngFor="let file of userFileStore | async">
	{{file.name}}
</div>
</code></pre>
		</section>
		<section>
			<h2>Useful Resources</h2>
			<ul>
				<li>Falcor</li>
				<li>GraphQl</li>
			</ul>
		</section>
		<section>
			<h2></h2>
			<a href="">Demo</a>
		</section>
	</div>
</div>

<script src="js/app.js"></script>
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script src="js/reveal.config.js"></script>

</body>
</html>
